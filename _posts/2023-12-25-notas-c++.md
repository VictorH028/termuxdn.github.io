


# Declaracion y extructura de un programa 

- **Declaraciones**

Un programa de computadora es una secuencia de instrucciones que le dicen a la computadora qué hacer. Una **declaración** es un tipo de instrucción que hace que el programa realice alguna acción 

> nota : La mayoría (pero no todas) las declaraciones en C++ terminan en punto y coma. Si ve una línea que termina en punto y coma, probablemente sea una declaración


- **Funciones y función principal**

En C++, las declaraciones normalmente se agrupan en unidades llamadas **funciones.** Una función es una colección de declaraciones que se ejecutan secuencialmente (en orden, de arriba a abajo). 


> Regala: Cada programa C++ debe tener una función especial llamada **main** (todas las letras minúsculas). Cuando se ejecuta el programa, las declaraciones dentro de mainse ejecutan en orden secuencial.

- **Errores de sintaxis y sintaxis**

En inglés, las oraciones se construyen de acuerdo con reglas gramaticales específicas que probablemente aprendiste en la clase de inglés en la escuela. Por ejemplo, las oraciones normales terminan en un punto. Las reglas que gobiernan cómo se construyen las oraciones en un idioma se llaman **sintaxis** . Si olvida el punto y ejecuta dos oraciones juntas, esto es una violación de la sintaxis del idioma inglés.

# Comentarios

Un comentario es una nota legible por el programador que se inserta directamente en el código fuente del programa. El compilador ignora los comentarios y son para uso exclusivo del programador

- **comentario de una sola linea**

El ``//`` símbolo comienza un comentario de una sola línea de C++, que le indica al compilador que ignore todo, desde el ``//``símbolo hasta el final de la línea. Por ejemplo:

```cpp
std::cout << "Hola Mundo"; \\ Esto es un comentario
```

- **comentario de varias lineas**

El par de símbolos ``/*`` y ``*/`` denota un comentario de varias líneas de estilo C. Todo lo que se encuentre entre los símbolos se ignora

```cpp
/* Todo lo que
esta
aca es un comentario
*/
```

> ⚠️ Advertencia: No utilice comentarios de varias líneas dentro de otros comentarios de varias líneas. Está bien incluir comentarios de una sola línea dentro de un comentario de varias líneas.

> Nota : Comente su código generosamente y escriba sus comentarios como si hablara con alguien que no tiene idea de lo que hace el código. No asuma que recordará por qué tomó decisiones específicas.

# Introducción a objetos y variables

Los ``datos`` son cualquier información que una computadora puede mover, procesar o almacenar.

Un ``valor`` es una letra (p. ej. `a`), un número (p. ej. `5`), un texto (p. ej. `hello`) o una instancia de algún otro concepto útil que pueda representarse como datos.

> nota : Los programas son conjuntos de instrucciones que manipulan datos para producir un resultado deseado.

- **Memoria de acceso aleatorio**

La memoria principal de una computadora se llama memoria de acceso aleatorio (a menudo llamada [RAM]() para abreviar). Cuando ejecutamos un programa, el sistema operativo carga el programa en la *RAM*. Cualquier dato que esté codificado en el propio programa (por ejemplo, texto como "¡Hola, mundo!") se carga en este punto.

- **Objetos y variables**

En C++, se desaconseja el acceso directo a la memoria. En cambio, accedemos a la memoria indirectamente a través de un objeto. Un objeto es una región de almacenamiento (normalmente memoria) que puede almacenar un valor y tiene otras propiedades asociadas.



- **Creación de instancias variables**

Para crear una variable, utilizamos un tipo especial de declaración llamada **definición**

Ejemplo de cómo definir una variable denominada ``x``:

```cpp
int x; // Define una variable x de tipo int
```

> Nota: Cuando se ejecuta el programa (llamado **tiempo de ejecución** ), se creará una instancia de la variable. La creación de instancias es una palabra elegante que significa que el objeto se creará y se le asignará una dirección de memoria. Se deben crear instancias de las variables antes de poder usarlas para almacenar valores. A modo de ejemplo, digamos que se crea una instancia de la variable x en la ubicación de memoria 140. Siempre que el programa use la variable x, accederá al valor en la ubicación de memoria 140. Un objeto instanciado a veces se denomina instancia .

- **Tipos de datos**

En C++, el tipo de una variable debe conocerse en **tiempo de compilación** (cuando se compila el programa), y ese tipo no se puede cambiar sin volver a compilar el programa. Esto significa que una variable entera sólo puede contener valores enteros. Si desea almacenar algún otro tipo de valor, deberá utilizar un tipo diferente.

# Asignación e inicialización de variables






# 4.12  Introducción a la conversión de tipos y ``static_cast`` 

- **Conversión de tipo implícita**

Cuando el compilador realiza una conversión de tipos en nuestro nombre sin que se lo solicitemos explícitamente, a esto lo llamamos **conversión de tipos implícita** .


> Nota: Algunas conversiones de tipos siempre son seguras (como inta double), mientras que otras pueden provocar que el valor cambie durante la conversión (como doublea int). Las conversiones implícitas inseguras normalmente generarán una advertencia del compilador o (en el caso de la inicialización de llaves) un error.

Esta es una de las razones principales por las que la inicialización con llaves es la forma de inicialización preferida. La inicialización de llaves garantizará que no intentemos inicializar una variable con un inicializador que perderá valor cuando se convierta implícitamente:

```cpp
int main()
{
    double d { 5 }; // okay: int to double is safe
    int x { 5.5 }; // error: double to int not safe

    return 0;
}
```
## Una introducción a la conversión de tipos explícita a través del operador ``static_cast``


C++ admite un segundo método de conversión de tipos, llamado conversión de tipos explícita. **La conversión de tipos explícita** nos permite (al programador) decirle explícitamente al compilador que convierta un valor de un tipo a otro, y que asumimos toda la responsabilidad por el resultado de esa conversión (lo que significa que si la conversión resulta en la pérdida de valor, es culpa nuestra).

Para realizar una conversión de tipo explícita, en la mayoría de los casos usaremos el *static_castoperador*. La sintaxis parece **static_cast** un poco divertida:

```
static_cast<nuevo_tipo>(expresión)
```

**static_cast** toma el valor de una expresión como entrada y devuelve ese valor convertido al tipo especificado por ``new_type`` (por ejemplo, int, bool, char, double).

**Convertir números sin signo a números con signo**

```cpp
int main(){
  usingend int u {5};
  int s {static_cast<int>(u)};
  std::cout << s << std::endl;
```

> Nota: El operador   `` static_cast `` producirá un comportamiento indefinido si el valor que se está convirtiendo no encaja en el rango del nuevo tipo.

# 2.1 Conceptos básicos de  funciones y archivo

Como avia mencionado anterior mente una función es una colección de declaraciones que se ejecutan secuencialmente.

- **sintaxis más básica para definir una función**

```cpp
retunType functionName(){
   // body
}
```
> Nota : Una funcion puede llamar otra funcion

```cpp
void a(){
  std::cout << "a" << std::endl;
}

void b(){
  a();
  std::cout << b << sdt::endl;
}

int main(){
  b();
}
```

Salida:
```
a
b
```

> Nota: Las funciones anidadas no son compatibles

# 11.6 — Plantillas de funciones

En C++, el sistema de plantillas fue diseñado para simplificar el proceso de creación de funciones (o clases) que puedan trabajar con diferentes tipos de datos


> : Nota  El compilador puede usar una única plantilla para generar una familia de funciones o clases relacionadas, cada una usando un conjunto diferente de tipos

```cpp
template <typename T> // esta es la declaración del parámetro de plantilla
T max( T x, T y) {
  return (x > y) ? x : y ;
}
``` 
# 11.7 — Creación de instancias de plantilla de función 

**Usando una plantilla de función**

Para usar nuestra `max<T>`  plantilla de funciones, podemos realizar una llamada de función con la siguiente sintaxis:

``max<tipo_actual>(arg1, arg2); // tipo_actual es algún tipo real, como int o double``


Podemos usar la **deducción de argumentos de plantilla** para que el compilador deduzca el tipo real que debe usarse a partir de los tipos de argumentos. en la llamada a la función.

```cpp
std::cout << max<>(1,2) << std::endl;
std::cout << max(1,2) << std::endl;
```

> Mejores prácticas
Favorezca la sintaxis de llamada de función normal al realizar llamadas a una función instanciada a partir de una plantilla de función (a menos que necesite que se prefiera la versión de la plantilla de función a una función coincidente que no sea de plantilla).

**Usar plantillas de funciones en múltiples archivos**

La forma más convencional de abordar este problema es colocar todo el código de la plantilla en un archivo de encabezado (.h) en lugar de un archivo fuente (.cpp):



# 14.1 — Introducción a la programación orientada a objetos

# 20.6 - Introducción a lambdas (funciones anónimas)

**Lambdas son funciones anónimas**

Una expresión lambda (también llamada lambda o cierre ) nos permite definir una función anónima dentro de otra función. El anidamiento es importante, ya que nos permite evitar la contaminación de nombres de espacios de nombres y definir la función lo más cerca posible de donde se usa (proporcionando contexto adicional).

La sintaxis de lambdas es una de las cosas más extrañas en C++ y requiere un poco de tiempo para acostumbrarse. Lambdas toman la forma:

```cpp
[captureClause] (parámetros) -> tipo de retorno
{
    declaraciones;
}
```
- La cláusula de captura puede estar vacía si no se necesitan capturas.

- La lista de parámetros puede estar vacía si no se requieren parámetros. También se puede omitir por completo a menos que se especifique un tipo de devolución

- El tipo de devolución es opcional y, si se omite, autose asumirá (por lo tanto, se utilizará la deducción de tipo utilizada para determinar el tipo de devolución). Si bien anteriormente señalamos que se debe evitar la deducción de tipos para los tipos de retorno de funciones, en este contexto, está bien usarla (porque estas funciones suelen ser muy triviales).

También tenga en cuenta que las lambdas (al ser anónimas) no tienen nombre, por lo que no es necesario que proporcionemos uno.


# 21.1 — Introducción a la sobrecarga del operador


El uso de la sobrecarga de funciones para sobrecargar operadores se denomina sobrecarga de operadores . 




